{"mappings":"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","sources":["node_modules/pubsub.js/pubsub.js"],"sourcesContent":["(function(scope) {\n\t'use strict';\n\tvar pubsubInstance = null;\n\tvar pubsubConfig = null;\n\n\tif(typeof pubsub === 'object') {\n\t\tpubsubConfig = pubsub;\n\t//node.js config from global\n\t} else if(typeof global === 'object' && typeof global.pubsubConfig === 'object') {\n\t\tpubsubConfig = global.pubsubConfig;\n\t}\n\n\tfunction Pubsub(config) {\n\t\tvar _eventObject = {};\n\t\tvar options = {\n\t\t\tseparator : (config && config.separator) ? config.separator : '/',\n\t\t\trecurrent : (config && typeof config.recurrent === 'boolean') ? config.recurrent : (false),\n\t\t\tdepth     : (config && typeof config.depth === 'number') ? config.depth : null,\n\t\t\tasync     : (config && typeof config.async === 'boolean') ? config.async : (false),\n\t\t\tcontext   : (config && config.context) ? config.context : null,\n\t\t\tlog       : (config && config.log) ? config.log : (false)\n\t\t};\n\n\t\tfunction forEach(dataArray, callback) {\n\t\t\tvar i = 0,\n\t\t\t\tarrayLength = dataArray.length;\n\n\t\t\tfor(i = 0; i < arrayLength; i++) {\n\t\t\t\tcallback(i, dataArray[i]);\n\t\t\t}\n\t\t}\n\n        function isArray (obj) {\n\t\t\treturn Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n        }\n\n        function executeCallback(subscriptions, args, async) {\n\t\t\tasync = (typeof async === 'boolean') ? async : options.async;\n\t\t\tif(!subscriptions.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// clone array - callbacks can unsubscribe other subscriptions\n\t\t\t// reduces a lot performance but is safe\n\t\t\tvar executedSubscriptions = subscriptions.slice();\n\n\t\t\tforEach(executedSubscriptions, function(subscriptionId, subscription) {\n\t\t\t\tif(typeof subscription === 'object' && executedSubscriptions.hasOwnProperty(subscriptionId)) {\n\t\t\t\t\tif(async) {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tsubscription.callback.apply(subscription.context, args);\n\t\t\t\t\t\t}, 4);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubscription.callback.apply(subscription.context, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction executePublishWildcard(nsObject, args) {\n\t\t\tvar nsElement;\n\t\t\tfor(nsElement in nsObject) {\n\t\t\t\tif(nsElement[0] !== '_' && nsObject.hasOwnProperty(nsElement)) {\n\t\t\t\t\texecuteCallback(nsObject[nsElement]._events, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction publish(nsObject, args, parts, params) {\n\t\t\t// work on copy - not on reference\n\t\t\tparts = parts.slice();\n\n\t\t\tvar iPart = parts.shift();\n\t\t\tvar depth = params.depth;\n\t\t\tvar async = params.async;\n\t\t\tvar partsLength = params.partsLength;\n\t\t\tvar recurrent = params.recurrent;\n\t\t\tvar partNumber = (partsLength - parts.length);\n\n\t\t\t// parts is empty\n\t\t\tif(!iPart) {\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// handle subscribe wildcard\n\t\t\tif(typeof nsObject['*'] !== 'undefined') {\n\t\t\t\tpublish(nsObject['*'], args, parts, params);\n\t\t\t}\n\n\t\t\t// handle publish wildcard\n\t\t\tif(iPart === '*') {\n\t\t\t\texecutePublishWildcard(nsObject, args, async);\n\t\t\t}\n\n\t\t\t// no namespace = leave publish\n\t\t\tif(typeof nsObject[iPart] === \"undefined\") {\n\t\t\t\tif(params.log) {\n\t\t\t\t\tconsole.warn('There is no ' + params.nsString + ' subscription');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnsObject = nsObject[iPart];\n\n\t\t\tif(recurrent === true && typeof depth !== 'number') { //depth is not defined\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t\tif(parts.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(recurrent === true && typeof depth === 'number' && partNumber >= (partsLength - depth)) { //if depth is defined\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t}\n\n\t\t\tpublish(nsObject, args, parts, params);\n\t\t}\n\n\t\tfunction executeSubscribeWildcard(nsObject, args, params) {\n\t\t\tvar parts = params.parts;\n\t\t\tvar async = params.async;\n\t\t\tvar nextPart = null;\n\n\t\t\tif(parts.length === 0) {\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t} else {\n\t\t\t\tnextPart = parts.shift();\n\n\t\t\t\tif(nsObject[nextPart]) {\n\t\t\t\t\texecuteSubscribeWildcard(nsObject[nextPart], args, {\n\t\t\t\t\t\tparts : parts,\n\t\t\t\t\t\tasync : async,\n\t\t\t\t\t\tnsString : params.nsString\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction subscribe(nsString, callback, params) {\n\t\t\tvar parts = nsString.split(options.separator),\n\t\t\t\tnsObject, //Namespace object to which we attach event\n\t\t\t\tcontext = (params && typeof params.context !== 'undefined') ? params.context : options.context,\n\t\t\t\teventObject = null,\n\t\t\t\ti = 0;\n\n\t\t\tif(!context) {\n\t\t\t\tcontext = callback;\n\t\t\t}\n\n\t\t\t//Iterating through _eventObject to find proper nsObject\n\t\t\tnsObject = _eventObject;\n\t\t\tfor(i = 0; i < parts.length; i += 1) {\n\t\t\t\tif(typeof nsObject[parts[i]] === \"undefined\") {\n\t\t\t\t\tnsObject[parts[i]] = {};\n\t\t\t\t\tnsObject[parts[i]]._events = [];\n\t\t\t\t}\n\t\t\t\tnsObject = nsObject[parts[i]];\n\t\t\t}\n\n\t\t\teventObject = {\n\t\t\t\tcallback\t: callback,\n\t\t\t\tcontext\t\t: context // \"this\" parameter in executed function\n\t\t\t};\n\n\t\t\tnsObject._events.push(eventObject);\n\t\t\treturn { namespace : parts.join(options.separator),\n\t\t\t\tevent : eventObject };\n\t\t}\n\n\t\tfunction unsubscribe(subscribeObject) {\n\t\t\tif(subscribeObject === null || typeof subscribeObject === 'undefined') {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar nsString = subscribeObject.namespace,\n\t\t\t\teventObject = subscribeObject.event,\n\t\t\t\tparts = nsString.split(options.separator),\n\t\t\t\tnsObject,\n\t\t\t\ti = 0;\n\n\t\t\t//Iterating through _eventObject to find proper nsObject\n\t\t\tnsObject = _eventObject;\n\t\t\tfor(i = 0; i < parts.length; i += 1) {\n\t\t\t\tif(typeof nsObject[parts[i]] === \"undefined\") {\n\t\t\t\t\tif(options.log) {\n\t\t\t\t\t\tconsole.error('There is no ' + nsString + ' subscription');\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tnsObject = nsObject[parts[i]];\n\t\t\t}\n\n\t\t\tforEach(nsObject._events, function(eventId) {\n\t\t\t\tif(nsObject._events[eventId] === eventObject) {\n\t\t\t\t\tnsObject._events.splice(eventId, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Publish event\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param args array of arguments given to callbacks\n\t\t\t * @param params paramaters possible:\n\t\t\t *        @param recurrent bool should execution be bubbled throught namespace\n\t\t\t *        @param depth integer how many namespaces separated by dots will be executed\n\t\t\t */\n\t\t\tpublish : function(nsString, args, params) {\n\t\t\t\tvar parts = nsString.split(options.separator),\n\t\t\t\t\trecurrent = (typeof params === 'object' && params.recurrent) ? params.recurrent : options.recurrent, // bubbles event throught namespace if true\n\t\t\t\t\tdepth = (typeof params === 'object' && params.depth) ? params.depth : options.depth,\n\t\t\t\t\tasync = (typeof params === 'object' && params.async) ? params.async : options.async,\n\t\t\t\t\tpartsLength = parts.length;\n\n\t\t\t\tif(!parts.length) {\n\t\t\t\t\tif(options.log) {\n\t\t\t\t\t\tconsole.error('Wrong namespace provided ' + nsString);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpublish(_eventObject, args, parts, {\n\t\t\t\t\trecurrent : recurrent,\n\t\t\t\t\tdepth : depth,\n\t\t\t\t\tasync : async,\n\t\t\t\t\tparts : parts,\n\t\t\t\t\tnsString : nsString,\n\t\t\t\t\tpartsLength : partsLength\n\t\t\t\t});\n\t\t\t},\n\t\t\t/**\n\t\t\t * Subscribe event\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param callback function function executed after publishing event\n\t\t\t * @param params given params\n\t\t\t *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n\t\t\t */\n\t\t\tsubscribe : function(nsString, callback, params) {\n\t\t\t\tvar self = this,\n\t\t\t\t\tsubscriptions = [];\n\n\t\t\t\t// array of callbacks - multiple subscription\n\t\t\t\tif(isArray(callback)) {\n\t\t\t\t\tforEach(callback, function(number) {\n\t\t\t\t\t\tvar oneCallback = callback[number];\n\n\t\t\t\t\t\tsubscriptions =\tsubscriptions.concat(self.subscribe(nsString, oneCallback, params));\n\t\t\t\t\t});\n\t\t\t\t// array of namespaces - multiple subscription\n\t\t\t\t} else if(isArray(nsString)) {\n\t\t\t\t\tforEach(nsString, function(number) {\n\t\t\t\t\t\tvar namespace = nsString[number];\n\n\t\t\t\t\t\tsubscriptions =\tsubscriptions.concat(self.subscribe(namespace, callback, params));\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn subscribe.apply(self, arguments);\n\t\t\t\t}\n\t\t\t\treturn subscriptions;\n\t\t\t},\n\t\t\t/**\n\t\t\t * subscribeOnce event - subscribe once to some event, then unsubscribe immadiately\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param callback function function executed after publishing event\n\t\t\t * @param params given params\n\t\t\t *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n\t\t\t */\n\t\t\tsubscribeOnce : function(nsString, callback, params) {\n\t\t\t\tvar self = this,\n\t\t\t\t\tsubscription = null;\n\n\t\t\t\tfunction subscriptionCallback() {\n\t\t\t\t\tvar context = this;\n\n\t\t\t\t\tcallback.apply(context, arguments);\n\t\t\t\t\tself.unsubscribe(subscription);\n\t\t\t\t}\n\n\t\t\t\tsubscription = self.subscribe(nsString, subscriptionCallback, params);\n\t\t\t\treturn subscription;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Unsubscribe from given subscription\n\t\t\t * @param subscribeObject subscription object given on subscribe (returned from subscription)\n\t\t\t */\n\t\t\tunsubscribe : function(subscribeObject) {\n\t\t\t\tvar self = this;\n\n\t\t\t\t//if we have array of callbacks - multiple subscription\n\t\t\t\tif(isArray(subscribeObject)) {\n\t\t\t\t\tforEach(subscribeObject, function(number) {\n\t\t\t\t\t\tvar oneSubscribtion = subscribeObject[number];\n\n\t\t\t\t\t\tunsubscribe.apply(self, [oneSubscribtion]);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tunsubscribe.apply(self, arguments);\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * newInstance - makes new instance of pubsub object with its own config\n\t\t\t * @param params instance configuration\n\t\t\t *        @param separator separator (default is \"/\")\n\t\t\t *        @param recurrent should publish events be bubbled through namespace\n\t\t\t *        @param async should publish events be asynchronous - not blocking function execution\n\t\t\t *        @param log console.warn/error every problem\n\t\t\t */\n\t\t\tnewInstance : function(params) {\n\t\t\t\treturn new Pubsub(params);\n\t\t\t}\n\t\t}; //return block\n\t}\n\tpubsubInstance = new Pubsub(pubsubConfig);\n\n\t//if sbd's using requirejs library to load pubsub.js\n\tif(typeof define === 'function') {\n\t\tdefine(pubsubInstance);\n\t}\n\n\t//node.js\n\tif(typeof module === 'object' && module.exports) {\n\t\tmodule.exports = pubsubInstance;\n\t}\n\n\tif(typeof window === 'object') {\n\t\twindow.pubsub = pubsubInstance;\n\t\tif(window !== scope) {\n\t\t\tscope.pubsub = pubsubInstance;\n\t\t}\n\t}\n})(this);\n"],"names":[],"version":3,"file":"index.bbfee37b.js.map","sourceRoot":"/__parcel_source_root/"}